#import "template.typ":*
#import "@preview/codelst:1.0.0": sourcecode
#import "@preview/cetz:0.1.0"

#let codelst-sourcecode = sourcecode
#let sourcecode = codelst-sourcecode.with(
frame: block.with(
fill: none,
stroke: none,
radius: 2pt,
inset: (x: 10pt, y: 5pt)
)
)

#let transpose(in_matrix)={
  let out_matrix = ()
  for i in range(0,in_matrix.at(0).len()) {
      out_matrix.push(())
      for j in range(0,in_matrix.len()) {
        out_matrix.at(i).push(in_matrix.at(j).at(i))
      }
    }

  return out_matrix
}

#show: project.with(
  title: [
    Курсова Робота\
    з дисципліни\
    Паралельні обчислення
  ],
  author: "Зарицький Кирило Андрійович"
)

#outline(
  title: [Зміст],
  depth: 3,
)

#set heading(numbering: "1.1.1")

#show heading.where(
  level: 1
): it => [
  #pagebreak(weak: true)
  #it.body
]

#pagebreak()
= Вступ

#[



]

= Теоретичні Відомості

#[

  == Інвертований індекс

  Інвестований індекс -- індекс бази даних, що зберігає асоціації з вмісту, як наприклад слова та числа, в їх розташування, таких як таблиці та документи (на відміну від прямого індексу, що ассоціює з документів в їх вміст)./*[1] Knuth, D. E. (1997) [1973]. "6.5. Retrieval on Secondary Keys". The Art of Computer Programming (Third ed.). Reading, Massachusetts: Addison-Wesley. ISBN 0-201-89685-0.*/ Основне призначення інвестованого індексу -- швидкий текстовий пошук за рахунок повільного розширення індексу. /*Salton, Gerard; Fox, Edward A.; Wu, Harry (November 1983). "Extended Boolean information retrieval". Communications of the ACM. 26 (11): 1022–1036. doi:10.1145/182.358466. hdl:1813/6351*/ Цей тип індексу активно використовується в пошукових системах. Існує два основні варіанти індексу: інвертований індекс рівня запису, що містить набір посилань на документи для кожного слова, та інвертований індекс рівня вмісту, де додатково додається позиція слова в документі.

  == Пул потоків

  

]

= Модель Системи

#[

  == Загальна Модель Системи

  #figure(
    image("../../model/main.svg"),
    caption: [Загальна модель системи],
  )<fig_modmain>

  На рисунку @fig_modmain зображено загальну модель системи. Маємо файли, що токенізуються і індексуються. Результат зберігається в інвертованому індексі та надходить до системи надання сервісу, що через IPC надає сервіс клієнту перетворюючи текстовий пошуковий запит у відповідний список документів.

  == Діаграма Діяльності

  #figure(
    image("../../model/SystemActivityDiagram.svg"),
    caption: [Діаграма Діяльності],
  )<fig_modact>

  На рисунку @fig_modact зображено діаграму діяльності моделі системи. Паралельна побудова індексу реалізована за рахунок паралельної обробки файлів. 
  
  Так як попередньо розподіл файлів в директоріях невідомий, було обрано метод асинхроного виконання функцій, зображений у формі процедур DirectoryTraversalTask та FileIndexationTask. 
  
  Такий підхід дозволяє розподіляти виконання файлів під час рекурсивного обходу наданих файлів. Недоліком підходу є відсутність розпаралелення при обробці самих файлів (процедура FileIndexationTask). Це може спричинити неоптимальне навантаження системи, коли серед файлів є велика дисперсія їх розмірів. Відсутність розпаралелення обробки директорій також може породжувати неоптимальний розподіл навантаження при достатньо великій кількості файлів в одній директорії.

  Єдиним місцем синхронізації отриманих процедур буде додавання пар "слово-документ" до індексу. Відповідно слід мінімізувати кількість роздільних редагувань індексу. Пропонується виконати це за рахунок додавань групами. Після завершення побудови індексу його синхронізація не потрібна, так-як він буде лише читатись.

  Паралельної обробки клієнтів виконується за рахунок асинхроного виклику процедури ClientHandler. Це просте рішення дозволить обробляти клієнтів паралельно. Воно є оптимальним для великої кількості клієнтів, але є неоптимальним, якщо клієнтів мало (у випадку пулу потоків, менша ніж кількість потоків). 

  Асинхроне виконання процедур пропонується виконати за рахунок пулу потоків.

  == Протокол Міжпроцесної Взаємодії

  #figure(
    image("../../model/IPC.svg"),
    caption: [Протокол Міжпроцесної Взаємодії],
  )<fig_modipc>

  На рисунку @fig_modipc зображено міжпроцесну взаємодію. Клієнт надсилає повідомлення, вміст якого -- текст пошукового запиту. Сервер отримує повідомлення, створує процедуру в пулі потоків, що оброблює запит та надсилає результат клієнту.

  Пакування пропонується зробити простим записом C подібної строки в тіло пакету. Для комунікації можна використати, що TCP, що UDP. У випадку TCP клієнт спочатку підключиться до сервера, відповідно сервер вже починаючи з цього моменту може відділити обробку в підпроцес. В розробленій реалізації якраз і використовується протокол TCP.

]

= Опис Реалізації

#[

  В цьому розділі буде розглянуто реалізацію моделі системи. Далі   буде розглянуто структуру проекту, опис його модулів та синхронізації в цих модулях. Також в кінці розділу є інструкція з   інсталювання.

  Загалом проект був розроблений на мові програмування C++ для Unix   подібних систем (в першу чергу Linux).

  == Структура Проекту

  #[
    Побудова, інсталювання та тестування проекту виконано за допомогою  системи CMake. Її конфігураційні файли розташовані в кореневій   директорії проекту та директорії tests.

    В директоріях include та src розташовані файли в яких описані     класи проекту (в "include\/\*.h" -- опис класів, а в "src\/\*.  cpp"  -- реалізації). Така місткова система є стандартною   практикою в  написанні C++ коду.

    В директорії exec розташованні функції main відповідних   виконавчих  файлів. В проекті збирається 4 програми:
      + CWServer -- програма, що збирає індекс та потім відкриває     інтернет сокет для надання сервісу.
      + CWClient -- програма-клієнт, що отримує сервіс.
      + CWMultiClient -- програма, що робить стрес-експеримент    запускаючи N потоків, що звертаються до сервісу одночасно.
      + tests/CommonCxxTests -- тести системи. В проекті є 5  модульних тестів, що можуть бути виконані в цій програмі   (зауважимо, що тести не виводять дані, тому для перевірки   корректності їх виконання слід дивитись на код, що вони   повертають (0 = успіх)):
        + invertedindex_write_multithread_test -- тест на   багатопоточний запис в індекс.
        + invertedindex_write_singlethread_test -- тест на  однопоточний запис в індекс.
        + threadpool_completion_test -- тест на завершення виконання  всіх завдань в пулі потоків.
        + threadpool_subscriber_test -- тест на перевірку підписки  на завершення роботи пулу потоків.
        + threadpool_thread_count_test -- тест на запуск правильної   кількості робочих потоків.

    В директоріях test_data та eval_data розташовані дані для   побудови індексу. Перший -- невеликий набір даних для наочної   перевірки роботи програми. Другий -- набір даних за варіантом   курсової роботи. Зауважимо, що користувач може сам надавати   програмі дані.

    В директорії doc розташована документація проекту. В директорії models -- діаграми моделі системи.
  ]

  == Опис Модулів

  #[
    Прогама має в собі 2 класи, 2 незалежні функції та головну функцію.

    === InvertedIndex
    defined in \<invertedindex.h>
    ```cpp
    class InvertedIndex;
    ```
    Реалізація інвертованого індексу. В середині він з себе представляє індивідуально реалізовану hash невпорядкований набір (hast-таблиця) з пар слово -- набір назв документів в яких воно з'являється(завдяки реалізації набір документів відсортований).  

    ==== (constructor)
    ```cpp
    InvertedIndex(const std::size_t initialSize = defaultInitialSize, const float loadFactor = defaultLoadFactor);
    ```
    Будує клас з заданим початковим розміром та заданим loadFactor.
    - *initialSize* -- початковий розмір масиву backets hash-таблиці.
    - *loadFactor* -- loadFactor hash-таблиці. Якщо цей вираз вірний:\
    $"elements in array"/"array size" > "loadFactor"$\
    то розмір масиву збільшується в двічі.
    
    ==== insert
    ```cpp
    void insert(const std::string token, const std::string document);
    ```
    Додає пару *token*-docu*ment до індексу. Цей метод блокуючий! Виконання цієї операції неможливе після виклику *finish*.
    - *token* -- слово, з яким асоційовується документ.
    - *document* -- назва документу, що буде асоційований зі словом.
    ==== insertBatch
    ```cpp
    void insertBatch(const std::vector<std::pair<std::string,std::string>>& pairs);
    ```
    Додає серію пар *token*-*document* до індексу. Цей метод блокуючий! Виконання цієї операції неможливе після виклику *finish*.
    - *pairs* -- масив пар слово-документ, що будуть додані до масиву.
    ==== find
    ```cpp
    bool find(const std::string token);
    ```
    Шукає слово *token* в масиві. Виконання цієї операції неможливе перед викликом *finish*.
    - *token* -- слово, що треба знайти.
    - *Повертає* -- _true_, якщо слово є в індексі та _false_ в іншому випадку.
    ==== read
    ```cpp
    const std::set<std::string>& read(const std::string token);
    ```
    Зчитує документи в яких зустрічається слово *token*. Виконання цієї операції неможливе перед викликом *finish*.
    - *token* -- слово, що треба знайти.
    - *Повертає* -- набір документів, в яких слово присутнє в індексі; кидає _std::exception_ в іншому випадку.
    ==== finish
    ```cpp
    void finish();
    ```
    Завершує редагування класу та відкриває його для читання.

    === ThreadPool
    defined in \<threadpool.h>
    ```cpp
    class ThreadPool;
    ```
    Реалізація пулу потоків. В середині використовує пріоритетну чергу для завдань.
    ==== Task
    ```cpp
    typedef std::pair<int, std::function<const int()>> Task;  
    ```
    Тип "завдання" є важливим для додавання завдань в чергу. Представляє з себе пару з цілого числа та функції, що бере 0 аргументів та повертає ціле число.
    ==== (constructor)
    ```cpp
    ThreadPool(unsigned int N, bool exitImmediatlyOnTerminate = false);
	  ThreadPool(const ThreadPool&) = delete;
	  ThreadPool(ThreadPool&& other) = delete;
	  ThreadPool& operator=(ThreadPool& rhs) = delete;
	  ThreadPool& operator=(ThreadPool&& rhs) = delete;
    ```
    Будує клас з заданою кількістю потоків та стандартною поведінкою деструктора. Зауважимо, що copy та move семантика для класу заборонені (видалені).
    - *N* -- кількість потоків пулу потоків.
    - *exitImmediatlyOnTerminate* -- поведінка виходу. В залежності від обраного значення буде змінена поведінка деструктора.
    ==== (destructor)
    ```cpp
	  ~ThreadPool();
    ```
    Зупиняє роботу класу. В залежності від значення флагу *exitImmediatlyOnTerminate*, заданому при створенні, буде викликано або terminateIm() для _true_, або terminate навпаки.
    ==== terminate/terminateIm
    ```cpp
	  void terminate();
	  void terminateIm();
    ```
    Зупиняє роботу класу. Всі потоки або відокремлюються при *terminateIm* або приєднуються до потоку виклику при *terminate*.
    ==== pause/unpause/pauseToggle
    ```cpp
	  void pause();
	  void unpause();
	  void pauseToggle();
    ```
    Призупиняє виконання наступних завдань. Ці функції не не призупиняють самі потоки, а лише не дають їм взяти нові завдання з черги.
    ==== addTask
    ```cpp
	  void addTask(Task task);
    ```
    Додає завдання в чергу.
    - *task* -- завдання, що буде додано.
    ==== removeTask
    ```cpp
	  void removeTask();
    ```
    Видаляє останнє завдання з черги.
    ==== currentQueueSize
    ```cpp
    unsigned int currentQueueSize();
    ```
    Повертає поточну довжину черги.
    ==== currentThreadStatus
    ```cpp
	  std::unordered_map<unsigned short, ThreadPool::threadStatusEnum> currentThreadStatus();
    ```
    Повертає поточний статус всіх потоків.
    ==== toString
    ```cpp
	  static const char* toString(ThreadPool::threadStatusEnum v)
    ```
    Повертає строку, що пояснює стан потоку.
    *v* -- статус потоку, який треба пояснити.
    ==== numberOfThreds
    ```cpp
    unsigned int numberOfThreds()
    ```
    Повертає кількість потоків в класі.
    ==== avgWaitTime
    ```cpp
	  double avgWaitTime();
    ```
    Повертає середній час очікування на завдання.
    ==== avgWaitTimeReset
    ```cpp
	  void avgWaitTimeReset();
    ```
    Скидує дані про середній час очікування.
    ==== avgQueueSize
    ```cpp
	  double avgQueueSize();
    ```
    Повертає середню довжину черги.
    ==== avgQueueSizeReset
    ```cpp
	  void avgQueueSizeReset();
    ```
    Скидує дані про середню довжину черги.
    ==== avgTaskCompletionTime
    ```cpp
	  double avgTaskCompletionTime();
    ```
    Повертає середній час виконання завдання.
    ==== avgTaskCompletionTimeReset
    ```cpp
	  void avgTaskCompletionTimeReset();
    ```
    Скидає дані про середній час виконання.
    ==== subscribeOnFinish
    ```cpp
	  std::pair<std::set<std::function<void ()>>::iterator, bool> subscribeOnFinish (std::function<void()> callback);
    ```
    Підписується на подію завершення виконання. Ця подія відбувається коли всі потоки очікують елементу черги та черга пуста.
    - *callback* -- функція, що буде викликана за настання події.
    - *Повертає* -- пару з іттератору, що вказує на додану функцію та флагу, що показує чи був елемент доданий до списку підписників.
    ==== unsubscribeOnFinish
    ```cpp
	  void unsubscribeOnFinish(std::set<std::function<void ()>>::iterator itterator);
    ```
    Відписатись від події завершення виконання.
    - *itterator* -- іттератор, що вказує на елемент, що був доданий.

    === HandleRegularFile
    defined in "exec/CWServer.cpp"
    ```cpp
    const int HandleRegularFile(const std::filesystem::path filePath, InvertedIndex& invIn);
    ```
    Процедура, що переглядає всі слова в файлі та будує їх набір. З цього набору формуються пари слово-документ, що потім всі разом додаються до індексу
    - *filePath* -- шлях до файлу.
    - *invertedIndex* -- індекс, до якого слід додати слова з файлу.

    === HandleFile
    defined in "exec/CWServer.cpp"
    ```cpp
    const int HandleFile(const std::filesystem::path filePath, ThreadPool& threadPool, InvertedIndex& invIn);
    ```
    Процедура, що оброблює файли. Якщо він директорія, то процедура переглядає його вміст додає рекурсивні виклики над цими файлами до пулу потоків. Якщо він звичайний файл, то додає процедуру HandleRegularFile над цим файлом до пулу потоків.
    - *filePath* -- шлях до файлу.
    - *threadPool* -- пул потоків, до якого слід додавати процедури.
    - *invertedIndex* -- індекс, що передається функції HandleRegularFile.
  ]

  == Опис синхронізації

  #[
    Синхронізація системи має бути присутня лише в двох місцях: реалізації пулу потоків та реалізації запису в індекс.

    Реалізація синхронізації пулу потоків є вирішення задачі розробників-споживачів. Виклики методів *addTask* тощо є розробником а потоки -- споживачами. Ця задача вирішена використанням м'ютекса, що блокує будь-які зміни в спільних даних (в першу чергу -- черги завдань) та умовної змінної.

    Паралельний запис в індекс відсутній. Ця операція є виключно синхронною, реалізованою за рахунок єдиного мютекса на запис. Таким чином щоб мінімізувати сповільнення від викликів м'ютексу слід виконувати роздільні записи як можна рідше. Для цього був зроблений метод *insertBatch*, що за одну синхронізацію додає цілий масив елементів.

    Також індекс має недопускати виконання запису та зчитування одночасно. Так як цього ніколи не відбувається в системі, це виконано методом finish, що відкриває індекс для читання та закриває для запису.
  ]

  == Керівництво з Встановлення Програми

  #[
    Перед встановленням програми на комп'ютері має бути встановлено команди cmake та make. Програма підтримується *лише для Unix подібних систем*.
    + Скачайте релізний код з репозиторію та розархівуйте його.
    + В кореневій директорії отриманого коду створіть директорію build та перейдіть в неї.
    + З директорії build виконайте команду "``` cmake ..```"
    + З директорії build виконайте команду "``` make```"
    Якщо обидві команди завершились без помилок з кодом 0, програму зібрано правильно і її можна знайти в директорії build (CWServer) разом з клієнтом (CWClient) та багатопоточним експериментом (CWMultiClient). Тести можна запустити з директорії build/tests/CommonCxxTests.
  ]
  
]

= Виконання програми

#[
  #figure(
    image("img/Exec1.png"),
    caption: [Виконання програми. Сервер викликається з програми socat та з програми CWClient],
  )

  #let index_build = csv("tabl/index_build.csv")
  #for i in range(index_build.len()) {
    for j in range(1,index_build.at(0).len()) {
      index_build.at(i).at(j) = float(index_build.at(i).at(j))
      if i != 0 {
        index_build.at(i).at(j) /= 1000000000
      }
    }
  }
  #figure(
      caption: [Час побудови в залежності від розміру даних для різної кількості потоків (red -- 1, aqua -- 2, green -- 4, blue -- 8, maroon -- 16)],
      cetz.canvas({
        import cetz.plot
        import cetz.draw:*

        plot.plot(
          size:(9,9),
          y-tick-step: 0.5, 
          x-label: "Розмір даних (%)", y-label: "Час виконання (нс)", 
        {
          plot.add(transpose(index_build.slice(0,2)).slice(1), 
            style: (stroke:red))
          plot.add(transpose((index_build.at(0),)+(index_build.at(2),)).slice(1),   
            style: (stroke:color.aqua))
          plot.add(transpose((index_build.at(0),)+(index_build.at(3),)).slice(1),
            style: (stroke:green))
          plot.add(transpose((index_build.at(0),)+(index_build.at(4),)).slice(1),     
            style: (stroke:blue))
          plot.add(transpose((index_build.at(0),)+(index_build.at(5),)).slice(1), 
            style: (stroke:maroon))
        })
      })
  )
  #let index_build2 = csv("tabl/index_build2.csv")
  #for i in range(index_build2.len()) {
    index_build2.at(i).at(0) = float(index_build2.at(i).at(0))
    index_build2.at(i).at(1) = float(index_build2.at(i).at(1))/1000000000
  }
  #figure(
      caption: [Час побудови в залежності від кількості потоків],
      cetz.canvas({
        import cetz.plot
        import cetz.draw:*

        plot.plot(
          size:(9,9),
          y-tick-step: 0.5, 
          x-label: "Кількість Потоків ", y-label: "Час виконання (нс)", 
        {
          plot.add(index_build2.slice(1))
        })
      })
  )
]

= Висновки

#[

]


