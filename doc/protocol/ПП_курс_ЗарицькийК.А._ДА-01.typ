#import "template.typ":*
#import "@preview/codelst:1.0.0": sourcecode
#import "@preview/cetz:0.1.0"

#let codelst-sourcecode = sourcecode
#let sourcecode = codelst-sourcecode.with(
frame: block.with(
fill: none,
stroke: none,
radius: 2pt,
inset: (x: 10pt, y: 5pt)
)
)

#let transpose(in_matrix)={
  let out_matrix = ()
  for i in range(0,in_matrix.at(0).len()) {
      out_matrix.push(())
      for j in range(0,in_matrix.len()) {
        out_matrix.at(i).push(in_matrix.at(j).at(i))
      }
    }

  return out_matrix
}

#show: project.with(
  title: [
    Курсова Робота\
    з дисципліни\
    Паралельні обчислення\
    на тему\
    "Розробка багатопоточного сервісу, що надає інвертований індекс"
  ],
  author: "Зарицький Кирило Андрійович"
)

#outline(
  title: [Зміст],
  depth: 3,
)

#set heading(numbering: "1.1.1")

#show heading.where(
  level: 1
): it => [
  #pagebreak(weak: true)
  #it.body
]

#pagebreak()
= Вступ

#[

  Паралельне виконання програм є важливою сучасною проблемою. Активна розробка багатопоточних процесорів дозволяє виконувати все більше команд одночасно, що є ефективним способом пришвидшити роботу. Хоча слід зауважити, що паралельність породжує ряд унікальних проблем, таких як стан гонки та взаємного блокування.

  В цій роботі буде розглянуто розробку програми-сервісу, що будує інвертований індекс та надає його як сервіс по мережевому сокету. При розробці акцент буде ставитись на паралельній роботі програми. Це буде включати паралельну побудову індексу та паралельне надання сервісу.

  Завданням роботи є:
  + Розробити програму побудови інвертованого індексу набору файлів
  + Зробити можливість пришвидшити час рішення, варіюючи кількість потоків;
  + Розробити програму доступу до створеного індексу.
  + Програма має бути реалізована за архітектурою клієнт-сервер з використанням міжпроцесної взаємодії «мережеві сокети».
  + Має бути реалізована багатопоточна обробка клієнтів за допомогою пулу потоків.
  + При побудові та користуванні індексом необхідно використовувати структуру даних з паралельним доступом, одночасно звертаючись до нього декількома потоками;
  + Має бути розроблена власна СД.
  + При праралелізації розподіл навантажень між процессами має бути оптимальним.
  + Система має бути описана.

]

= Теоретичні Відомості

#[

  == Інвертований індекс

  Інвестований індекс -- індекс бази даних, що зберігає асоціації з вмісту, як наприклад слова та числа, в їх розташування, таких як таблиці та документи (на відміну від прямого індексу, що ассоціює з документів в їх вміст). Основне призначення інвестованого індексу -- швидкий текстовий пошук за рахунок повільного розширення індексу.  Цей тип індексу активно використовується в пошукових системах. Існує два основні варіанти індексу: інвертований індекс рівня запису, що містить набір посилань на документи для кожного слова, та інвертований індекс рівня вмісту, де додатково додається позиція слова в документі.

  == Пул потоків

  Пул потоків -- програмний дизайн для досягнення паралельності виконання в комп'ютерній програмі. Часто також називається реплікованими робітниками чи моделлю робітник-бригада, пул потоків зберігає кілька потоків, що чекають на завдання для одночасного виконання наглядаючою програмою. Зберігаючи пул потоків, модель підвищує продуктивність та уникає затримок у виконанні, які виникають через часте створення та знищення потоків для короткочасних завдань. Кількість доступних потоків налаштована відповідно до обчислювальних ресурсів, доступних програмі, таких як паралельна черга завдань після завершення виконання.

  Кількість потоків може динамічно коригуватися протягом життєвого циклу програми залежно від кількості очікуючих завдань. Наприклад, веб-сервер може додавати потоки, якщо надходить велика кількість запитів на веб-сторінки, і може видаляти потоки, коли ці запити зменшуються. Вартість використання більшого пулу потоків - це збільшене використання ресурсів. Алгоритм, який визначає, коли створювати або знищувати потоки, впливає на загальну продуктивність:

  - Створення занадто багатьох потоків витрачає ресурси і коштує часу на створення невикористаних потоків.
  - Знищення занадто багатьох потоків вимагає більше часу при подальшому їх створенні.
  - Створення потоків занадто повільно може призвести до поганої продуктивності клієнта (довгих часів очікування).
  - Знищення потоків занадто повільно може голодувати інші процеси ресурсами.

]

= Модель Системи

#[

  == Загальна Модель Системи

  #figure(
    image("../../model/main.png"),
    caption: [Загальна модель системи],
  )<fig_modmain>

  На рисунку @fig_modmain зображено загальну модель системи. Маємо файли, що токенізуються і індексуються. Результат зберігається в інвертованому індексі та надходить до системи надання сервісу, що через IPC надає сервіс клієнту перетворюючи текстовий пошуковий запит у відповідний список документів.

  == Діаграма Діяльності

  #figure(
    image("../../model/SystemActivityDiagram.png"),
    caption: [Діаграма Діяльності],
  )<fig_modact>

  На рисунку @fig_modact зображено діаграму діяльності моделі системи. Паралельна побудова індексу реалізована за рахунок паралельної обробки файлів. 
  
  Так як попередньо розподіл файлів в директоріях невідомий, було обрано метод асинхроного виконання функцій, зображений у формі процедур DirectoryTraversalTask та FileIndexationTask. 
  
  Такий підхід дозволяє розподіляти виконання файлів під час рекурсивного обходу наданих файлів. Недоліком підходу є відсутність розпаралелення при обробці самих файлів (процедура FileIndexationTask). Це може спричинити неоптимальне навантаження системи, коли серед файлів є велика дисперсія їх розмірів. Відсутність розпаралелення обробки директорій також може породжувати неоптимальний розподіл навантаження при достатньо великій кількості файлів в одній директорії.

  Єдиним місцем синхронізації отриманих процедур буде додавання пар "слово-документ" до індексу. Відповідно слід мінімізувати кількість роздільних редагувань індексу. Пропонується виконати це за рахунок додавань групами. Після завершення побудови індексу його синхронізація не потрібна, так-як він буде лише читатись.

  Паралельної обробки клієнтів виконується за рахунок асинхроного виклику процедури ClientHandler. Це просте рішення дозволить обробляти клієнтів паралельно. Воно є оптимальним для великої кількості клієнтів, але є неоптимальним, якщо клієнтів мало (у випадку пулу потоків, менша ніж кількість потоків). 

  Асинхроне виконання процедур пропонується виконати за рахунок пулу потоків.

  == Протокол Міжпроцесної Взаємодії

  #figure(
    image("../../model/IPC.png"),
    caption: [Протокол Міжпроцесної Взаємодії],
  )<fig_modipc>

  На рисунку @fig_modipc зображено міжпроцесну взаємодію. Клієнт надсилає повідомлення, вміст якого -- текст пошукового запиту. Сервер отримує повідомлення, створує процедуру в пулі потоків, що оброблює запит та надсилає результат клієнту.

  Пакування пропонується зробити простим записом C подібної строки в тіло пакету. Для комунікації можна використати, що TCP, що UDP. У випадку TCP клієнт спочатку підключиться до сервера, відповідно сервер вже починаючи з цього моменту може відділити обробку в підпроцес. В розробленій реалізації якраз і використовується протокол TCP.

]

= Опис Реалізації

#[

  В цьому розділі буде розглянуто реалізацію моделі системи. Далі   буде розглянуто структуру проекту, опис його модулів та синхронізації в цих модулях. Також в кінці розділу є інструкція з   інсталювання.

  Загалом проект був розроблений на мові програмування C++ для Unix   подібних систем (в першу чергу Linux).

  == Структура Проекту

  #[
    Побудова, інсталювання та тестування проекту виконано за допомогою  системи CMake. Її конфігураційні файли розташовані в кореневій   директорії проекту та директорії tests.

    В директоріях include та src розташовані файли в яких описані     класи проекту (в "include\/\*.h" -- опис класів, а в "src\/\*.  cpp"  -- реалізації). Така місткова система є стандартною   практикою в  написанні C++ коду.

    В директорії exec розташованні функції main відповідних   виконавчих  файлів. В проекті збирається 4 програми:
      + CWServer -- програма, що збирає індекс та потім відкриває     інтернет сокет для надання сервісу.
      + CWClient -- програма-клієнт, що отримує сервіс.
      + CWMultiClient -- програма, що робить стрес-експеримент    запускаючи N потоків, що звертаються до сервісу одночасно.
      + tests/CommonCxxTests -- тести системи. В проекті є 5  модульних тестів, що можуть бути виконані в цій програмі   (зауважимо, що тести не виводять дані, тому для перевірки   корректності їх виконання слід дивитись на код, що вони   повертають (0 = успіх)):
        + invertedindex_write_multithread_test -- тест на   багатопоточний запис в індекс.
        + invertedindex_write_singlethread_test -- тест на  однопоточний запис в індекс.
        + threadpool_completion_test -- тест на завершення виконання  всіх завдань в пулі потоків.
        + threadpool_subscriber_test -- тест на перевірку підписки  на завершення роботи пулу потоків.
        + threadpool_thread_count_test -- тест на запуск правильної   кількості робочих потоків.

    В директоріях test_data та eval_data розташовані дані для   побудови індексу. Перший -- невеликий набір даних для наочної   перевірки роботи програми. Другий -- набір даних за варіантом   курсової роботи. Зауважимо, що користувач може сам надавати   програмі дані.

    В директорії doc розташована документація проекту. В директорії models -- діаграми моделі системи.
  ]

  == Опис Модулів

  #[
    Прогама має в собі 2 класи, 2 незалежні функції та головну функцію.

    === InvertedIndex
    defined in \<invertedindex.h>
    ```cpp
    class InvertedIndex;
    ```
    Реалізація інвертованого індексу. В середині він з себе представляє індивідуально реалізовану hash невпорядкований набір (hast-таблиця) з пар слово -- набір назв документів в яких воно з'являється(завдяки реалізації набір документів відсортований).  

    ==== (constructor)
    ```cpp
    InvertedIndex(const std::size_t initialSize = defaultInitialSize, const float loadFactor = defaultLoadFactor);
    ```
    Будує клас з заданим початковим розміром та заданим loadFactor.
    - *initialSize* -- початковий розмір масиву backets hash-таблиці.
    - *loadFactor* -- loadFactor hash-таблиці. Якщо цей вираз вірний:\
    $"elements in array"/"array size" > "loadFactor"$\
    то розмір масиву збільшується в двічі.
    
    ==== insert
    ```cpp
    void insert(const std::string token, const std::string document);
    ```
    Додає пару *token*-docu*ment до індексу. Цей метод блокуючий! Виконання цієї операції неможливе після виклику *finish*.
    - *token* -- слово, з яким асоційовується документ.
    - *document* -- назва документу, що буде асоційований зі словом.
    ==== insertBatch
    ```cpp
    void insertBatch(const std::vector<std::pair<std::string,std::string>>& pairs);
    ```
    Додає серію пар *token*-*document* до індексу. Цей метод блокуючий! Виконання цієї операції неможливе після виклику *finish*.
    - *pairs* -- масив пар слово-документ, що будуть додані до масиву.
    ==== find
    ```cpp
    bool find(const std::string token);
    ```
    Шукає слово *token* в масиві. Виконання цієї операції неможливе перед викликом *finish*.
    - *token* -- слово, що треба знайти.
    - *Повертає* -- _true_, якщо слово є в індексі та _false_ в іншому випадку.
    ==== read
    ```cpp
    const std::set<std::string>& read(const std::string token);
    ```
    Зчитує документи в яких зустрічається слово *token*. Виконання цієї операції неможливе перед викликом *finish*.
    - *token* -- слово, що треба знайти.
    - *Повертає* -- набір документів, в яких слово присутнє в індексі; кидає _std::exception_ в іншому випадку.
    ==== finish
    ```cpp
    void finish();
    ```
    Завершує редагування класу та відкриває його для читання.

    === ThreadPool
    defined in \<threadpool.h>
    ```cpp
    class ThreadPool;
    ```
    Реалізація пулу потоків. В середині використовує пріоритетну чергу для завдань.
    ==== Task
    ```cpp
    typedef std::pair<int, std::function<const int()>> Task;  
    ```
    Тип "завдання" є важливим для додавання завдань в чергу. Представляє з себе пару з цілого числа та функції, що бере 0 аргументів та повертає ціле число.
    ==== (constructor)
    ```cpp
    ThreadPool(unsigned int N, bool exitImmediatlyOnTerminate = false);
	  ThreadPool(const ThreadPool&) = delete;
	  ThreadPool(ThreadPool&& other) = delete;
	  ThreadPool& operator=(ThreadPool& rhs) = delete;
	  ThreadPool& operator=(ThreadPool&& rhs) = delete;
    ```
    Будує клас з заданою кількістю потоків та стандартною поведінкою деструктора. Зауважимо, що copy та move семантика для класу заборонені (видалені).
    - *N* -- кількість потоків пулу потоків.
    - *exitImmediatlyOnTerminate* -- поведінка виходу. В залежності від обраного значення буде змінена поведінка деструктора.
    ==== (destructor)
    ```cpp
	  ~ThreadPool();
    ```
    Зупиняє роботу класу. В залежності від значення флагу *exitImmediatlyOnTerminate*, заданому при створенні, буде викликано або terminateIm() для _true_, або terminate навпаки.
    ==== terminate/terminateIm
    ```cpp
	  void terminate();
	  void terminateIm();
    ```
    Зупиняє роботу класу. Всі потоки або відокремлюються при *terminateIm* або приєднуються до потоку виклику при *terminate*.
    ==== pause/unpause/pauseToggle
    ```cpp
	  void pause();
	  void unpause();
	  void pauseToggle();
    ```
    Призупиняє виконання наступних завдань. Ці функції не не призупиняють самі потоки, а лише не дають їм взяти нові завдання з черги.
    ==== addTask
    ```cpp
	  void addTask(Task task);
    ```
    Додає завдання в чергу.
    - *task* -- завдання, що буде додано.
    ==== removeTask
    ```cpp
	  void removeTask();
    ```
    Видаляє останнє завдання з черги.
    ==== currentQueueSize
    ```cpp
    unsigned int currentQueueSize();
    ```
    Повертає поточну довжину черги.
    ==== currentThreadStatus
    ```cpp
	  std::unordered_map<unsigned short, ThreadPool::threadStatusEnum> currentThreadStatus();
    ```
    Повертає поточний статус всіх потоків.
    ==== toString
    ```cpp
	  static const char* toString(ThreadPool::threadStatusEnum v)
    ```
    Повертає строку, що пояснює стан потоку.
    *v* -- статус потоку, який треба пояснити.
    ==== numberOfThreds
    ```cpp
    unsigned int numberOfThreds()
    ```
    Повертає кількість потоків в класі.
    ==== avgWaitTime
    ```cpp
	  double avgWaitTime();
    ```
    Повертає середній час очікування на завдання.
    ==== avgWaitTimeReset
    ```cpp
	  void avgWaitTimeReset();
    ```
    Скидує дані про середній час очікування.
    ==== avgQueueSize
    ```cpp
	  double avgQueueSize();
    ```
    Повертає середню довжину черги.
    ==== avgQueueSizeReset
    ```cpp
	  void avgQueueSizeReset();
    ```
    Скидує дані про середню довжину черги.
    ==== avgTaskCompletionTime
    ```cpp
	  double avgTaskCompletionTime();
    ```
    Повертає середній час виконання завдання.
    ==== avgTaskCompletionTimeReset
    ```cpp
	  void avgTaskCompletionTimeReset();
    ```
    Скидає дані про середній час виконання.
    ==== subscribeOnFinish
    ```cpp
	  std::pair<std::set<std::function<void ()>>::iterator, bool> subscribeOnFinish (std::function<void()> callback);
    ```
    Підписується на подію завершення виконання. Ця подія відбувається коли всі потоки очікують елементу черги та черга пуста.
    - *callback* -- функція, що буде викликана за настання події.
    - *Повертає* -- пару з іттератору, що вказує на додану функцію та флагу, що показує чи був елемент доданий до списку підписників.
    ==== unsubscribeOnFinish
    ```cpp
	  void unsubscribeOnFinish(std::set<std::function<void ()>>::iterator itterator);
    ```
    Відписатись від події завершення виконання.
    - *itterator* -- іттератор, що вказує на елемент, що був доданий.

    === HandleRegularFile
    defined in "exec/CWServer.cpp"
    ```cpp
    const int HandleRegularFile(const std::filesystem::path filePath, InvertedIndex& invIn);
    ```
    Процедура, що переглядає всі слова в файлі та будує їх набір. З цього набору формуються пари слово-документ, що потім всі разом додаються до індексу
    - *filePath* -- шлях до файлу.
    - *invertedIndex* -- індекс, до якого слід додати слова з файлу.

    === HandleFile
    defined in "exec/CWServer.cpp"
    ```cpp
    const int HandleFile(const std::filesystem::path filePath, ThreadPool& threadPool, InvertedIndex& invIn);
    ```
    Процедура, що оброблює файли. Якщо він директорія, то процедура переглядає його вміст додає рекурсивні виклики над цими файлами до пулу потоків. Якщо він звичайний файл, то додає процедуру HandleRegularFile над цим файлом до пулу потоків.
    - *filePath* -- шлях до файлу.
    - *threadPool* -- пул потоків, до якого слід додавати процедури.
    - *invertedIndex* -- індекс, що передається функції HandleRegularFile.
  ]

  == Опис синхронізації

  #[
    Синхронізація системи має бути присутня лише в двох місцях: реалізації пулу потоків та реалізації запису в індекс.

    Реалізація синхронізації пулу потоків є вирішення задачі розробників-споживачів. Виклики методів *addTask* тощо є розробником а потоки -- споживачами. Ця задача вирішена використанням м'ютекса, що блокує будь-які зміни в спільних даних (в першу чергу -- черги завдань) та умовної змінної.

    Паралельний запис в індекс відсутній. Ця операція є виключно синхронною, реалізованою за рахунок єдиного мютекса на запис. Таким чином щоб мінімізувати сповільнення від викликів м'ютексу слід виконувати роздільні записи як можна рідше. Для цього був зроблений метод *insertBatch*, що за одну синхронізацію додає цілий масив елементів.

    Також індекс має недопускати виконання запису та зчитування одночасно. Так як цього ніколи не відбувається в системі, це виконано методом finish, що відкриває індекс для читання та закриває для запису.
  ]

  == Керівництво з Встановлення Програми

  #[
    Перед встановленням програми на комп'ютері має бути встановлено команди cmake та make. Програма підтримується *лише для Unix подібних систем*.
    + Скачайте релізний код з репозиторію та розархівуйте його.
    + В кореневій директорії отриманого коду створіть директорію build та перейдіть в неї.
    + З директорії build виконайте команду "``` cmake ..```"
    + З директорії build виконайте команду "``` make```"
    Якщо обидві команди завершились без помилок з кодом 0, програму зібрано правильно і її можна знайти в директорії build (CWServer) разом з клієнтом (CWClient) та багатопоточним експериментом (CWMultiClient). Тести можна запустити з директорії build/tests/CommonCxxTests.
  ]
  
]

= Виконання програми

#[
  #figure(
    image("img/Exec1.png"),
    caption: [Виконання програми. Сервер викликається з програми socat та з програми CWClient],
  )

  #let index_build = csv("tabl/index_build.csv")
  #for i in range(index_build.len()) {
    for j in range(1,index_build.at(0).len()) {
      index_build.at(i).at(j) = float(index_build.at(i).at(j))
      if i != 0 {
        index_build.at(i).at(j) /= 1000000000
      }
    }
  }
  #figure(
      caption: [Час побудови в залежності від розміру даних для різної кількості потоків (red -- 1, aqua -- 2, green -- 4, blue -- 8, maroon -- 16)],
      cetz.canvas({
        import cetz.plot
        import cetz.draw:*

        plot.plot(
          size:(9,9),
          y-tick-step: 0.5, 
          x-label: "Розмір даних (%)", y-label: "Час виконання (нс)", 
        {
          plot.add(transpose(index_build.slice(0,2)).slice(1), 
            style: (stroke:red))
          plot.add(transpose((index_build.at(0),)+(index_build.at(2),)).slice(1),   
            style: (stroke:color.aqua))
          plot.add(transpose((index_build.at(0),)+(index_build.at(3),)).slice(1),
            style: (stroke:green))
          plot.add(transpose((index_build.at(0),)+(index_build.at(4),)).slice(1),     
            style: (stroke:blue))
          plot.add(transpose((index_build.at(0),)+(index_build.at(5),)).slice(1), 
            style: (stroke:maroon))
        })
      })
  )
  #let index_build2 = csv("tabl/index_build2.csv")
  #for i in range(index_build2.len()) {
    index_build2.at(i).at(0) = float(index_build2.at(i).at(0))
    index_build2.at(i).at(1) = float(index_build2.at(i).at(1))/1000000000
  }
  #figure(
      caption: [Час побудови в залежності від кількості потоків],
      cetz.canvas({
        import cetz.plot
        import cetz.draw:*

        plot.plot(
          size:(9,9),
          y-tick-step: 0.5, 
          x-label: "Кількість Потоків ", y-label: "Час виконання (нс)", 
        {
          plot.add(index_build2)
        })
      })
  )<fig_JtoT>
]

= Висновки

#[

  В результаті виконання курсової роботи було розроблено програму-сервіс, що будує інвертований індекс та надає доступ до нього через мережевий сокет. 
  
  Побудову та обробку клієнтів програма виконує у багатопоточному режимі. Це було реалізовано за рахунок асинхроних процедур, що виконуються в пулі потоків. Результуюча система має високе прискорення у порівнянні з однопоточним виконанням (що можна спостерігати на рисунку @fig_JtoT).

  При цьому система має ряд недоліків. Система будує індекс лише один раз та не підтримує його розширення. Пропонується реалізовувати розширення індексу за рахунок створення копії індексу та редагування її. Коли редагування завершено надання сервісу призупиняється та індекс заміняється на потрібний

  Ще одним недоліком є неоптимальність моделі системи для нерівномірного розподілу розмірів файлів, як файли не розбиваютсья на частини для обробки. Відповідно слід провести експеримент з розділом файлів при побудові індексів.

  Зауважимо, що експерименти, проведені над програмою мають недолік: велику зашумленість вимірів. Для більш точного вимірювання слід виконувати багато однотипних експериментів та агрегувати їх результати. У експериментах з часом виконання це робилось 5 разів, але цього не достатньо для точного результату.

]

= Список Літератури

+ Семеренко В. Технології паралельних обчислень / Василь Семеренко. – Вінниця, 2018. – 105с. – (Вінницький Національний Технічний Університет).
+ Manning C. Introduction to Information Retrieval / Christopher Manning. – Cambridge, 2008. – 506 с. – (Cambridge University Press). – ISBN-13 978-0521865715.
+ CMake Reference Documentation [Електронний ресурс] /\/ Kitware, Inc. and Contributors. – 2023. – Режим доступу до ресурсу: https://cmake.org/cmake/help/latest/index.html
+ C++ Reference [Електронний ресурс] /\/ cppreference.com – 2023. – Режим доступу до ресурсу: https://en.cppreference.com/w/